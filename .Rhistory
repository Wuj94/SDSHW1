equality = m_steps(k=5, m = p, U = matrix_arr[[i]][[1]],
V = matrix_arr[[i]][[2]],
W = matrix_arr[[i]][[3]])
if(length(equality[equality == 'FALSE']) > 0){
res = c(res, FALSE) # not equal
}
else {
res = c(res, TRUE)
}
}
for (i in 1:5){
equality = m_steps(k=5, m = p, U = matrix_arr[[i]][[1]],
V = matrix_arr[[i]][[2]],
W = matrix_arr[[i]][[3]])
if(length(equality[equality == 'FALSE']) > 0){
res = c(res, FALSE) # not equal
}
else {
res = c(res, TRUE)
}
}
matrix_arr = list()
n_matrices = 5
for (i in 1:n_matrices){
temp = list()
for (j in 1:3){
temp[[j]] <- generate_random_matrix(k=5)
}
matrix_arr[[i]] = temp
}
p = 100
res = c()
for (i in 1:n_matrices){
equality = m_steps(k=5, m = p, U = matrix_arr[[i]][[1]],
V = matrix_arr[[i]][[2]],
W = matrix_arr[[i]][[3]])
if(length(equality[equality == 'FALSE']) > 0){
res = c(res, FALSE) # not equal
}
else {
res = c(res, TRUE)
}
}
res
matrix_arr = list()
n_matrices = 50
for (i in 1:n_matrices){
temp = list()
for (j in 1:3){
temp[[j]] <- generate_random_matrix(k=5)
}
matrix_arr[[i]] = temp
}
p = 100
res = c()
for (i in 1:n_matrices){
equality = m_steps(k=5, m = p, U = matrix_arr[[i]][[1]],
V = matrix_arr[[i]][[2]],
W = matrix_arr[[i]][[3]])
if(length(equality[equality == 'FALSE']) > 0){
res = c(res, FALSE) # not equal
}
else {
res = c(res, TRUE)
}
}
res
n_matrices = 500
for (i in 1:n_matrices){
temp = list()
for (j in 1:3){
temp[[j]] <- generate_random_matrix(k=5)
}
matrix_arr[[i]] = temp
}
p = 100
res = c()
for (i in 1:n_matrices){
equality = m_steps(k=5, m = p, U = matrix_arr[[i]][[1]],
V = matrix_arr[[i]][[2]],
W = matrix_arr[[i]][[3]])
if(length(equality[equality == 'FALSE']) > 0){
res = c(res, FALSE) # not equal
}
else {
res = c(res, TRUE)
}
}
res
sum(res[res == TRUE])
7/500
library(manipulate)
install.packages("manipulate")
library(manipulate)
res
p = 100
res = c()
for (i in 1:n_matrices){
equality = m_steps(k=5, m = p, U = matrix_arr[[i]][[1]],
V = matrix_arr[[i]][[2]],
W = matrix_arr[[i]][[3]])
if(length(equality[equality == 'FALSE']) > 0){
res = c(res, FALSE) # not equal
}
else {
res = c(res, TRUE)
}
}
res
n_matrices
sum(res[res == TRUE])
a = vector()
?vector
results <-vector(NA, length = p)
results <-vector(mode="numeric", length = p)
results
# iterative bayes for p from 1 to 50
p <- 50
p.error <- .5 # less than .5
results <- vector(mode="numeric", length = p)
results[1] <- .5 # personal probabilistic assumption
for(i in 1:p){
p.e.given.b <- (results[i]) / (results[i] + p.error*(1 - results[i]))
if( i != p )
results[i + 1] <- p.e.given.b
}
results
manipulate(plot(results,
xlim=c(0,x.max)),
x.max=slider(1,p))
p.error <- .2 # less than .5
results <- vector(mode="numeric", length = p)
results[1] <- .5 # personal probabilistic assumption
for(i in 1:p){
p.e.given.b <- (results[i]) / (results[i] + p.error*(1 - results[i]))
if( i != p )
results[i + 1] <- p.e.given.b
}
library(manipulate)
manipulate(plot(results,
xlim=c(0,x.max)),
x.max=slider(1,p))
results
results[1] <- .2 # personal probabilistic assumption
for(i in 1:p){
p.e.given.b <- (results[i]) / (results[i] + p.error*(1 - results[i]))
if( i != p )
results[i + 1] <- p.e.given.b
}
library(manipulate)
manipulate(plot(results,
xlim=c(0,x.max)),
x.max=slider(1,p))
results
results[1] <- .5 # personal probabilistic assumption
for(i in 1:p){
p.e.given.b <- (results[i]) / (results[i] + p.error*(1 - results[i]))
if( i != p )
results[i + 1] <- p.e.given.b
}
library(manipulate)
manipulate(plot(results,
xlim=c(0,x.max)),
x.max=slider(1,p))
results
# 1.a. --------------------------------------------------------------------
ks <- c(5, 50, 100, 500)
res.a <- vector()
iter.times <- vector(length=5)
for( i in 1:length(ks)){
start.time <- Sys.time()
res.a <- c(res.a, m_steps(k=ks[i], m=1))
end.time <- Sys.time()
iter.times[i] <- end.time - start.time
}
names(iter.times) <- ks
iter.times
# 1.a. --------------------------------------------------------------------
ks <- c(5, 50, 100, 500)
res.a <- vector()
iter.times <- vector(length=4)
for( i in 1:length(ks)){
start.time <- Sys.time()
res.a <- c(res.a, m_steps(k=ks[i], m=1))
end.time <- Sys.time()
iter.times[i] <- end.time - start.time
}
names(iter.times) <- ks
# 1.b ---------------------------------------------------------------------
ks = c(5, 50, 100, 500)
iter.times
?graph
??graph
?plot
plot(x = names(iter.times), y = iter.times)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension', ylab = 'exec time')
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension', ylab = 'exec time', main='one step algorithm')
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension', ylab = 'exec time', main='one step algorithm', type = "l")
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension', ylab = 'exec time', main='one step algorithm', type = "s")
?axis
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension', ylab = 'exec time', main='one step algorithm', type = "s", xaxt='n')
axis(side = 1, at = ks)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', xaxt='n')
axis(side = 1, at = ks)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', xaxt='n', type='b' )
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', xaxt='n', type='s')
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', xaxt='n')
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', xaxt='n', type='s')
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', xaxt='n', type='b')
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', xaxt='n')
lines(x = names(iter.times), y = iter.times)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', xaxt='n', type='s')
points(x = names(iter.times), y = iter.times)
axis(side = 1, at = ks)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks)
# 1.a. --------------------------------------------------------------------
ks <- c(5, 50, 100,200,300, 500)
res.a <- vector()
iter.times <- vector(length=6)
for( i in 1:length(ks)){
start.time <- Sys.time()
res.a <- c(res.a, m_steps(k=ks[i], m=1))
end.time <- Sys.time()
iter.times[i] <- end.time - start.time
}
names(iter.times) <- ks
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks)
# 1.a. --------------------------------------------------------------------
ks <- c(5, 50, 100, 500)
res.a <- vector()
iter.times <- vector(length=5)
for( i in 1:length(ks)){
start.time <- Sys.time()
res.a <- c(res.a, m_steps(k=ks[i], m=1))
end.time <- Sys.time()
iter.times[i] <- end.time - start.time
}
names(iter.times) <- ks
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks)
lines(y=2^x)
lines(y=2^(ks))
lines(y=2^(ks))
lines(y=2^(ks), x = ks)
lines(y=2^(ks), x = ks, add =T)
?curve
curve(2^x, add = T)
curve(expr=2^x, add = T)
curve(2^x, add = T)
curve(2^x)
curve(2^x, add = TRUE)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks)
lines(y=2^(ks), x = ks, add =T)
curve(2^x, add = TRUE)
curve(2^x, add = TRUE)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks)
lines(y=2^(ks), x = ks, add =T)
plot(func1, add = T)
plot(func1)
func1 <- plot(x) e^x
plot(func1)
func1 <- plot(x) exp(x)
func1 <- function(x) exp(x)
plot(func1)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks)
func1 <- function(x) exp(x)
plot(func1, add=T)
plot(func1, add=T)
func1 <- function(x) exp(x)
plot(func1, add=T)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', type='s')#,xaxt='n')
lines(x, x^2)
lines(x, iter.times^2)
lines(iter.times, iter.times^2)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm')# type='s')#,xaxt='n')
lines(iter.times, iter.times^2)
lines(x=iter.times, y=iter.times^2)
lines(x=iter.times, y=iter.times^2)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm')# type='s')#,xaxt='n')
lines(x=iter.times, y=iter.times^2)
iter.times
# 1.a. --------------------------------------------------------------------
ks <- c(5, 50, 100, 500)
res.a <- vector()
iter.times <- vector(length=4)
for( i in 1:length(ks)){
start.time <- Sys.time()
res.a <- c(res.a, m_steps(k=ks[i], m=1))
end.time <- Sys.time()
iter.times[i] <- end.time - start.time
}
names(iter.times) <- ks
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm')# type='s')#,xaxt='n')
lines(x=iter.times, y=iter.times^2)
lines(x=iter.times, y=iter.times^2)
iter.times
func1 <- function(x) return(x^2)
lines(x=iter.times, y=func1)
lines(x=iter.times, y=func1(x))
lines(x=iter.times, y=func1(iter.times))
lines(x, x^2))
lines(5, 5^2)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm')# type='s')#,xaxt='n')
func1 <- function(x) return(x^2)
lines(5, 5^2)
curve(func1, add=T)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm')# type='s')#,xaxt='n')
func1 <- function(x) x^2
curve(func1, add=T)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm')# type='s')#,xaxt='n')
func1 <- function(x) x^2
curve(func1, add=T)
curve(func1, add=T)
curve(func1, add=T)
plot(x = names(iter.times), y = func1, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm')
plot(x = names(iter.times), y = func1(), xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm')
plot(x = names(iter.times), y = func1(iter.times), xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm')
plot(x = names(iter.times), y = func1(iter.times), xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', type='s')
plot(x = names(iter.times), y = func1(iter.times), xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', type='l')
plot(x = names(iter.times), y = func1(iter.times), xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', type='b')
func1(iter.times)
iter.times
plot(x = names(iter.times), y = func1(ks), xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', type='b')
plot(x = names(iter.times), y = func1(ks), xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', type='l')
names(iter.times) <- ks
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm')# type='s')#,xaxt='n')
func1 <- function(x) x^2
curve(func1, add=T)
plot(x = names(iter.times), y = func1(ks), xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', type='l', add=T)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', type='s',xaxt='n')
plot(x = names(iter.times), y = func1(ks), xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', type='l', add=T)
plot(x = names(iter.times), y = func1(ks), xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', type='l', ylim=iter.times[4],
add=T)
names(iter.times) <- ks
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', type='s',xaxt='n')
func1 <- function(x) x^2
line(ks, func1(ks), add=T)
line(ks, func1(ks))
abline(ks, func1(ks))
curve(ks, func1(ks))
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', type='s',xaxt='n')
func1 <- function(x) x^2
xaxt='n'
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks)
iter.times
plot(x = names(iter.times), y = iter.times^2, xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', xaxt='n', type='s')
plot(x = names(iter.times), y = log(iter.times), xlab = 'matrix dimension',
ylab = 'exec time', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks)
plot(x = names(iter.times), y = log(iter.times), xlab = 'matrix dimension',
ylab = 'exec time (log scale)', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks)
curve(theor.time.comp)
theor.time.comp <- function(x) 0.00000617027*(x^2)
curve(theor.time.comp)
names(iter.times) <- ks
plot(x = names(iter.times), y = log(iter.times), xlab = 'matrix dimension',
ylab = 'exec time (log scale)', main='one step algorithm', xaxt='n', type='s')
names(iter.times) <- ks
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time (log scale)', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks)
theor.time.comp <- function(x) 0.00000617027*(x^2)
curve(theor.time.comp, add=T)
theor.time.comp()
iter.times
theor.time.comp <- function(x) (2.2068024e-7)*(x^2)
curve(theor.time.comp, add=T)
theor.time.comp <- function(x) (1.8823147e-7)*(x^2)
curve(theor.time.comp, add=T)
theor.time.comp <- function(x) (1.7006588e-7)*(x^2)
curve(theor.time.comp, add=T)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time (log scale)', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks)
theor.time.comp <- function(x) (1.7006588e-7)*(x^2)
curve(theor.time.comp, add=T)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension',
ylab = 'exec time (log scale)', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks)
theor.time.comp <- function(x) (1.7006588e-7)*(x^2)
curve(theor.time.comp, color='green',add=T)
?curve
?line
?plot
curve(theor.time.comp, add=T, col='green')
# 1.b ---------------------------------------------------------------------
ks = c(5, 50, 100, 500)
m = 100
# 1.b ---------------------------------------------------------------------
ks = c(5, 50, 100, 500)
m = 100
prop = vector()
for( i in 1:length(ks)){
res.b = c(m_steps(k=ks[i], m=m))
t = table(res.b) / length(res.b)
prop = c(prop, t['TRUE'])
}
prop
for( i in 1:length(ks)){
res.b = c(m_steps(k=ks[i], m=m))
t = table(res.b) / length(res.b)
prop = c(prop, t['TRUE'])
}
prop
ks = c(5, 50, 100, 500)
ms = c(1000, 10000)
prop = vector()
seq.start.time <- Sys.time()
ks = c(5, 50, 100, 500)
ms = c(1000, 10000)
prop = vector()
seq.start.time <- Sys.time()
for( i in 1:length(ks)){
for( j in 1:length(ms)){
res.b = c(m_steps(k=ks[i], m=ms[j]))
t = table(res.b) / length(res.b)
prop = c(prop, t['TRUE'])
}
}
seq.end.time <- Sys.time()
seq.tot.time <- seq.end.time - seq.start.time
# 1.c.parallel ------------------------------------------------------------
library(foreach)
library(doParallel)
ks = c(5, 50, 100, 500)
ms = c(1000, 10000)
par.start.time <- Sys.time()
cl <- parallel::makeForkCluster()
doParallel::registerDoParallel(cl)
a <- foreach(i = 1:length(ks), .combine = 'c') %:% foreach(j = 1:length(ms)) %dopar% {
res.b = c(m_steps(k=ks[i], m=ms[j]))
t = table(res.b) / length(res.b)
t['TRUE']
}
parallel::stopCluster(cl)
par.end.time <- Sys.time()
par.tot.time <- par.end.time - par.start.time
seq.tot.time
par.tot.time
??makeForkCluster
ks = c(5, 50, 100, 500)
ms = c(1000, 10000)
par.start.time <- Sys.time()
cl <- parallel::makeForkCluster(nnodes=4)
doParallel::registerDoParallel(cl)
a <- foreach(i = 1:length(ks), .combine = 'c') %:% foreach(j = 1:length(ms)) %dopar% {
res.b = c(m_steps(k=ks[i], m=ms[j]))
t = table(res.b) / length(res.b)
t['TRUE']
}
parallel::stopCluster(cl)
par.end.time <- Sys.time()
par.tot.time <- par.end.time - par.start.time
par.tot.time
ks = c(5, 50, 100, 500)
ms = c(1000, 10000)
par.start.time <- Sys.time()
cl <- parallel::makeForkCluster(nnodes=8)
doParallel::registerDoParallel(cl)
a <- foreach(i = 1:length(ks), .combine = 'c') %:% foreach(j = 1:length(ms)) %dopar% {
res.b = c(m_steps(k=ks[i], m=ms[j]))
t = table(res.b) / length(res.b)
t['TRUE']
}
parallel::stopCluster(cl)
par.end.time <- Sys.time()
par.tot.time <- par.end.time - par.start.time
