generate_random_matrix <- function(k=5) {
M <- matrix(rbinom(k*k, 1,.5), nrow=k)
return(M)
}
# array containing k values for each matrix (5, 50, 100, 500)
ks <- c(5, 50, 100, 500)
# initalizing 'results vector' (it will contain the results of the proportion)
res.a <- vector()
# inizializing 'execution times vector' (execution time of one-step algo for each matrix)
iter.times <- vector(length=4)
for( i in 1:length(ks)){
start.time <- Sys.time()
# m_steps takes in input the actual k and m=1 (one-step algo)
# and gives as output the result
res.a <- c(res.a, m_steps(k=ks[i], m=1))
end.time <- Sys.time()
iter.times[i] <- end.time - start.time
}
generate_random_matrix <- function(k=5) {
M <- matrix(rbinom(k*k, 1,.5), nrow=k)
return(M)
}
# array containing k values for each matrix (5, 50, 100, 500)
ks <- c(5, 50, 100, 500)
# initalizing 'results vector' (it will contain the results of the proportion)
res.a <- vector()
for( i in 1:length(ks)){
res.a <- c(res.a, generate_random_matrix(ks[i]))
}
res.a
??list
generate_random_matrix <- function(k=5) {
M <- matrix(rbinom(k*k, 1,.5), nrow=k)
return(M)
}
# array containing k values for each matrix (5, 50, 100, 500)
ks <- c(5, 50, 100, 500)
# initalizing 'results vector' (it will contain the results of the proportion)
res.a <- array()
for( i in 1:length(ks)){
res.a <- c(res.a, generate_random_matrix(ks[i]))
}
res.a
??array
?array
# array containing k values for each matrix (5, 50, 100, 500)
ks <- c(5, 50, 100, 500)
# initalizing 'results vector' (it will contain the results of the proportion)
res.a <- array(dim=length(ks))
for( i in 1:length(ks)){
res.a <- c(res.a, generate_random_matrix(ks[i]))
}
res.a
for( i in 1:length(ks)){
res.a[i] <- c(res.a, generate_random_matrix(ks[i]))
}
# initalizing 'results vector' (it will contain the results of the proportion)
res.a <- array(dim=length(ks))
for( i in 1:length(ks)){
res.a[i] <-  generate_random_matrix(ks[i])
}
# initalizing 'results vector' (it will contain the results of the proportion)
res.a <- array(dim=length(ks))
res.a
res[i]
res.a[1]
res[i] <- 1
res[i] <- 1
res[1] <- 1
res.a[1] <- 1
res.a[1]
?matrix
res.a[1] <- matrix(nrow = 3, ncol = 3)
?list
# initalizing 'results vector' (it will contain the results of the proportion)
res.a <- list()
for( i in 1:length(ks)){
res.a[i] <-  generate_random_matrix(ks[i])
}
# initalizing 'results vector' (it will contain the results of the proportion)
res.a <- list()
for( i in 1:length(ks)){
res.a[[i]] <-  generate_random_matrix(ks[i])
}
res.a
for( i in 1:1){#length(ks)){
res.a[[i]] <-  generate_random_matrix(ks[i])
}
res.a
# array containing k values for each matrix (5, 50, 100, 500)
ks <- c(5, 50, 100, 500)
# initalizing 'results vector' (it will contain the results of the proportion)
res.a <- list()
for( i in 1:1){#length(ks)){
res.a[[i]] <-  generate_random_matrix(ks[i])
}
res.a
# initalizing 'results vector' (it will contain the results of the proportion)
res.a <- list()
for( i in 1:2){#length(ks)){
res.a[[i]] <-  generate_random_matrix(ks[i])
}
res.a
generate_random_matrix(50)
# array containing k values for each matrix (5, 50, 100, 500)
ks <- c(5, 50, 100, 500)
# initalizing 'results vector' (it will contain the results of the proportion)
res.a <- list()
for( i in 1:length(ks)){
res.a[[i]] <-  generate_random_matrix(ks[i])
}
generate_random_matrix <- function(k=5) {
M <- matrix(rbinom(k*k, 1,.5), nrow=k)
return(M)
}
check_triplet <- function(U,V,W) {
stopifnot(dim(U) == dim(V) && dim(V) == dim(W))
equal <- T
if(identical((U %*% V) %% 2, W)){
equal <- F
}
return(equal)
}
# array containing k values for each matrix (5, 50, 100, 500)
ks <- c(5, 50, 100, 500)
# initalizing the list which contains the matrices
res.a <- list()
for( i in 1:length(ks)){
check.non.identity <- F
triplet <- list()
while ( check.non.identity == F){
U <- generate_random_matrix(ks[i])
V <- generate_random_matrix(ks[i])
Z <- generate_random_matrix(ks[i])
check.non.identity <- check_triplet(U,V,W)
if( check.non.identity == T){
triplet[[1]] <- U
triplet[[2]] <- V
triplet[[3]] <- W
}
}
res.a[i] <- triplet
}
for( i in 1:length(ks)){
check.non.identity <- F
triplet <- list()
while ( check.non.identity == F){
U <- generate_random_matrix(ks[i])
V <- generate_random_matrix(ks[i])
W <- generate_random_matrix(ks[i])
check.non.identity <- check_triplet(U,V,W)
if( check.non.identity == T){
triplet[[1]] <- U
triplet[[2]] <- V
triplet[[3]] <- W
}
}
res.a[i] <- triplet
}
for( i in 1:length(ks)){
check.non.identity <- F
triplet <- list()
while ( check.non.identity == F){
U <- generate_random_matrix(ks[i])
V <- generate_random_matrix(ks[i])
W <- generate_random_matrix(ks[i])
check.non.identity <- check_triplet(U,V,W)
if( check.non.identity == T){
triplet[[1]] <- U
triplet[[2]] <- V
triplet[[3]] <- W
}
}
res.a[[i]] <- triplet
}
res.a
ks = c(5, 50, 100, 500)
m = 100
one_step <- function(U, V, W) {
stopifnot(dim(U) == dim(V) && dim(V) == dim(W))
z <- array(rbinom(dim(U)[1], 1, .5))
res <- (U %*% ((V %*% z) %% 2)) %% 2
if( identical
(res, (W %*% z) %% 2) ){
return(F)
} else {
return(T)
}
}
m_steps <- function(k = 5, m = 100, U = generate_random_matrix(k),
V = generate_random_matrix(k),
W = generate_random_matrix(k)) {
stopifnot(k > 0 && m > 0)
stopifnot(dim(U) == dim(V) && dim(V) == dim(W))
a = c(one_step(U,V,W))
if(m > 1) {
for( i in 2:m ) {
a = c(a, one_step(U,V,W))
}
}
return(a)
}
m = 100
prop = vector()
for( i in 1:length(ks)){
res.b = c(m_steps(k=ks[i], m=m))
t = table(res.b) / length(res.b)
prop = c(prop, t['TRUE'])
}
prop
prop = 1 - prop
prop
error <- 1 - prop
names(error) <- c("5", "50", "100","500")
error
error.k <- 1 - prop
names(error.k) <- c("5", "50", "100","500")
error.k
error.k <- 1 - prop
names(error.k) <- c("5", "50", "100","500")
error.k
m_steps <- function(k = 5, m = 100, U = generate_random_matrix(k),
V = generate_random_matrix(k),
W = generate_random_matrix(k)) {
stopifnot(k > 0 && m > 0)
stopifnot(dim(U) == dim(V) && dim(V) == dim(W))
a <- c(one_step(U,V,W))
if(m > 1) {
for( i in 2:m ) {
a = c(a, one_step(U,V,W))
}
}
return(a)
}
m <- 100
prop  <- vector()
for( i in 1:length(ks)){
res.b <- c(m_steps(k=ks[i], m=m))
t = table(res.b) / length(res.b)
prop <- c(prop, t['TRUE'])
}
error.k <- 1 - prop
names(error.k) <- c("5", "50", "100","500")
error.k
library(foreach)
library(doParallel)
ks = c(5, 50, 100, 500)
ms = c(1000, 10000)
par.start.time <- Sys.time()
cl <- parallel::makeForkCluster(nnodes=8)
doParallel::registerDoParallel(cl)
a <- foreach(i = 1:length(ks), .combine = 'c') %:% foreach(j = 1:length(ms)) %dopar% {
res.b = c(m_steps(k=ks[i], m=ms[j]))
t = table(res.b) / length(res.b)
t['TRUE']
}
a <- foreach(i = 1:length(ks), .combine = 'c') %:% foreach(j = 1:length(ms)) %dopar% {
res.b = c(m_steps(k=ks[i], m=ms[j]))
t = table(res.b) / length(res.b)
t['TRUE']
}
parallel::stopCluster(cl)
par.end.time <- Sys.time()
par.tot.time <- par.end.time - par.start.time
par.tot.time
library(foreach)
library(doParallel)
ks = c(5, 50, 100, 500)
ms = c(1000, 10000)
par.start.time <- Sys.time()
cl <- parallel::makeForkCluster(nnodes=8)
doParallel::registerDoParallel(cl)
a <- foreach(i = 1:length(ks), .combine = 'c') %:% foreach(j = 1:length(ms)) %dopar% {
res.b = c(m_steps(k=ks[i], m=ms[j]))
t = table(res.b) / length(res.b)
t['TRUE']
}
parallel::stopCluster(cl)
par.end.time <- Sys.time()
par.tot.time <- par.end.time - par.start.time
par.tot.time
```{r}
library(foreach)
library(doParallel)
ks = c(5, 50, 100, 500)
ms = c(1000, 10000)
par.start.time <- Sys.time()
cl <- parallel::makeForkCluster()
doParallel::registerDoParallel(cl)
a <- foreach(i = 1:length(ks), .combine = 'c') %:% foreach(j = 1:length(ms)) %dopar% {
res.b = c(m_steps(k=ks[i], m=ms[j]))
t = table(res.b) / length(res.b)
t['TRUE']
}
parallel::stopCluster(cl)
par.end.time <- Sys.time()
par.tot.time <- par.end.time - par.start.time
par.tot.time
ks = c(5, 50, 100, 500)
ms = c(1000, 10000)
prop = vector()
seq.start.time <- Sys.time()
for( i in 1:length(ks)){
for( j in 1:length(ms)){
res.b = c(m_steps(k=ks[i], m=ms[j]))
t = table(res.b) / length(res.b)
prop = c(prop, t['TRUE'])
}
}
seq.end.time <- Sys.time()
seq.tot.time <- seq.end.time - seq.start.time
seq.tot.time
```{r}
prop = vector()
seq.start.time <- Sys.time()
for( i in 1:length(ks)){
for( j in 1:length(ms)){
res.b = c(m_steps(k=ks[i], m=ms[j]))
t = table(res.b) / length(res.b)
prop = c(prop, t['TRUE'])
}
}
seq.end.time <- Sys.time()
seq.tot.time <- seq.end.time - seq.start.time
seq.tot.time
par.tot.time
# array containing k values for each matrix (5, 50, 100, 500)
ks <- c(5, 50, 100, 500)
# initalizing 'results vector' (it will contain the results of the proportion)
res.a <- vector()
# inizializing 'execution times vector' (execution time of one-step algo for each matrix)
iter.times <- vector(length=4)
for( i in 1:length(ks)){
start.time <- Sys.time()
# m_steps takes in input the actual k and m=1 (one-step algo)
# and gives as output the result
res.a <- c(res.a, m_steps(k=ks[i], m=1))
end.time <- Sys.time()
iter.times[i] <- end.time - start.time
}
# plotting execution times results
names(iter.times) <- ks
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension', col = "dodgerblue3",
ylab = 'exec time (log scale)', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks)
# describing the theoretical function y= ak^2 approximating the unknown constant 'a'
# with the empirical value of execution time for the k = 500 matrix (a ~ time_k_500 / 500^2)
theor.time.comp <- function(x) (iter.times[4]/500^2)*x^2
curve(theor.time.comp, add=T, col='chartreuse3')
# array containing k values for each matrix (5, 50, 100, 500)
ks <- c(5, 50, 100, 500)
# initalizing 'results vector' (it will contain the results of the proportion)
res.a <- vector()
# inizializing 'execution times vector' (execution time of one-step algo for each matrix)
iter.times <- vector(length=4)
# now, for every type of k, do one-step algorithm (m-step with m=1)
# and concatenate the results in res.a (True if the matrices are different)
for( i in 1:length(ks)){
start.time <- Sys.time()
# m_steps takes in input the actual k and m=1 (one-step algo)
# and gives as output the result
res.a <- c(res.a, m_steps(k=ks[i], m=1))
end.time <- Sys.time()
iter.times[i] <- end.time - start.time
}
# plotting execution times results
names(iter.times) <- ks
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension', col = "dodgerblue3",
ylab = 'exec time (log scale)', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks)
# describing the theoretical function y= ak^2 approximating the unknown constant 'a'
# with the empirical value of execution time for the k = 500 matrix (a ~ time_k_500 / 500^2)
theor.time.comp <- function(x) (iter.times[4]/500^2)*x^2
curve(theor.time.comp, add=T, col='chartreuse3')
axis(side = 1, at = ks)
# plotting execution times results
names(iter.times) <- ks
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension', col = "dodgerblue3",
ylab = 'exec time (log scale)', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks)
# plotting execution times results
names(iter.times) <- ks
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension', col = "dodgerblue3",
ylab = 'exec time (log scale)', main='one step algorithm', xaxt='n', type='s')
# describing the theoretical function y= ak^2 approximating the unknown constant 'a'
# with the empirical value of execution time for the k = 500 matrix (a ~ time_k_500 / 500^2)
theor.time.comp <- function(x) (iter.times[4]/500^2)*x^2
curve(theor.time.comp, add=T, col='chartreuse3')
# plotting execution times results
names(iter.times) <- ks
# plotting execution times results
names(iter.times) <- ks
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension', col = "dodgerblue3", ylab = 'exec time (log scale)', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks)
axis(side = 1, at = ks, add = T)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension', col = "dodgerblue3", ylab = 'exec time (log scale)', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks, add = T)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension', col = "dodgerblue3", ylab = 'exec time (log scale)', main='one step algorithm', xaxt='n', type='s')
axis(side = 1, at = ks, add = T)
axis(side = 1, at = ks)
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension', col = "dodgerblue3", ylab = 'exec time (log scale)', main='one step algorithm', xaxt='n', type='s') + axis(side = 1, at = ks)
# describing the theoretical function y= ak^2 approximating the unknown constant 'a'
# with the empirical value of execution time for the k = 500 matrix (a ~ time_k_500 / 500^2)
theor.time.comp <- function(x) (iter.times[4]/500^2)*x^2
curve(theor.time.comp, add=T, col='chartreuse3')
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension', col = "dodgerblue3", ylab = 'exec time (log scale)', main='one step algorithm', xaxt='n', type='s') + axis(side = 1, at = ks)
# describing the theoretical function y= ak^2 approximating the unknown constant 'a'
# with the empirical value of execution time for the k = 500 matrix (a ~ time_k_500 / 500^2)
theor.time.comp <- function(x) (iter.times[4]/500^2)*x^2
cur
plot(x = names(iter.times), y = iter.times, xlab = 'matrix dimension', col = "dodgerblue3", ylab = 'exec time (log scale)', main='one step algorithm', xaxt='n', type='s') + axis(side = 1, at = ks)
# describing the theoretical function y= ak^2 approximating the unknown constant 'a'
# with the empirical value of execution time for the k = 500 matrix (a ~ time_k_500 / 500^2)
theor.time.comp <- function(x) (iter.times[4]/500^2)*x^2
curve(theor.time.comp, add=T, col='chartreuse3')
ms = c(1000, 10000)
library(foreach)
library(doParallel)
ms = c(1000, 10000)
par.start.time <- Sys.time()
cl <- parallel::makeForkCluster()
doParallel::registerDoParallel(cl)
a <- foreach(i = 1:length(ks), .combine = 'c') %:% foreach(j = 1:length(ms)) %dopar% {
res.b = c(m_steps(k=ks[i], m=ms[j]))
t = table(res.b) / length(res.b)
t['TRUE']
}
parallel::stopCluster(cl)
par.end.time <- Sys.time()
par.tot.time <- par.end.time - par.start.time
# iterative bayes for p from 1 to 50
p <- 50
p.error <- .5 # less than .5
results <- vector(mode="numeric", length = p)
results[1] <- .5 # personal probabilistic assumption
for(i in 1:p){
p.e.given.b <- (results[i]) / (results[i] + p.error*(1 - results[i]))
if( i != p )
results[i + 1] <- p.e.given.b
}
library(manipulate)
manipulate(plot(results,
xlim=c(0,x.max)),
x.max=slider(1,p))
knitr::opts_chunk$set(echo = TRUE)
# iterative bayes for p from 1 to 50
p <- 50
p.error <- .5 # less than .5
results <- vector(mode="numeric", length = p)
results[1] <- .5 # personal probabilistic assumption
for(i in 1:p){
p.e.given.b <- (results[i]) / (results[i] + p.error*(1 - results[i]))
if( i != p )
results[i + 1] <- p.e.given.b
}
# iterative bayes for p from 1 to 50
p <- 50
p.error <- .5 # less than .5
results <- vector(mode="numeric", length = p)
results[1] <- .5 # personal probabilistic assumption
for(i in 1:p){
p.e.given.b <- (results[i]) / (results[i] + p.error*(1 - results[i]))
if( i != p )
results[i + 1] <- p.e.given.b
}
# 2.d ---------------------------------------------------------------------
library(manipulate)
manipulate(plot(results,
xlim=c(0,x.max)),
x.max=slider(1,p))
# iterative bayes for p from 1 to 50
p <- 50
p.error <- .5 # less than .5
results <- vector(mode="numeric", length = p)
results[1] <- .5 # personal probabilistic assumption
for(i in 1:p){
p.e.given.b <- (results[i]) / (results[i] + p.error*(1 - results[i]))
if( i != p )
results[i + 1] <- p.e.given.b
}
# 2.d ---------------------------------------------------------------------
library(manipulate)
manipulate(plot(results,
xlim=c(0,x.max)),
x.max=slider(1,p))
# 2.d ---------------------------------------------------------------------
library(manipulate)
manipulate(plot(results,
xlim=c(0,x.max)),
x.max=slider(1,p))
library(manipulate)
manipulate(plot(results, xlim=c(0,x.max)),  x.max=slider(1,p))
#manipulate(plot(results, xlim=c(0,x.max)),  x.max=slider(1,p))
manipulate(plot(1:x), x = slider(1, 100))
library(manipulate)
#manipulate(plot(results, xlim=c(0,x.max)),  x.max=slider(1,p))
manipulate(plot(1:x), x = slider(1, 100))
#manipulate(plot(results, xlim=c(0,x.max)),  x.max=slider(1,p))
manipulate(plot(1:x), x = slider(1, 100))
library(manipulate)
library(manipulate)
manipulate(plot(results, xlim=c(0,x.max)),  x.max=slider(1,p))
manipulate(plot(1:x), x = slider(1, 100))
library(manipulate)
manipulate(plot(results,
xlim=c(0,x.max)),
x.max=slider(1,p))
library(manipulate)
manipulate(plot(results,
xlim=c(0,x.max)),
x.max=slider(1,p))
manipulate(plot(results, xlim=c(0,x.max)),  x.max=slider(1,p))
